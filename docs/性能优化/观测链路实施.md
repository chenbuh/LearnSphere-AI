# Observability Pipeline (Phase 1)

This doc records the initial end-to-end observability work (frontend → backend → Prometheus).

## Backend

- Actuator + Prometheus registry enabled.
- Metrics endpoint:
  - `GET /actuator/prometheus`
- Common tags:
  - `application` = `${spring.application.name}`
  - `env` = `${spring.profiles.active}`

### Custom Metrics

- `ai.request.latency` (Timer)
  - tags: `action`, `model`, `status`, `cache`
- `ai.request.total` (Counter)
  - tags: `action`, `model`, `status`
- `ai.tokens.total` (Counter)
  - tags: `model`, `type` (`input`/`output`)
- `cache.access.total` (Counter)
  - tags: `result` (`attempt`/`hit`/`miss`/`error`)
- `frontend.web_vital` (DistributionSummary)
  - tags: `name`, `path`
- `frontend.api.latency` (Timer)
  - tags: `endpoint`, `method`, `status`
- `frontend.route.latency` (Timer)
  - tags: `from`, `to`
- `frontend.event.total` (Counter)
  - tags: `type`, `name`

## Frontend

- Web Vitals captured: `FCP`, `LCP`, `CLS`, `INP`
- API latency captured for all `/api` calls (axios)
- Route navigation latency captured on `beforeEach` + `afterEach`
- Batch report endpoint:
  - `POST /api/metrics/frontend`
  - body: `{ metrics: FrontendMetricDTO[] }`

## Grafana Quick Start (PromQL examples)

- AI P95 latency:
  - `histogram_quantile(0.95, sum(rate(ai_request_latency_bucket[5m])) by (le))`
- AI failure rate:
  - `sum(rate(ai_request_total{status="FAIL"}[5m])) / sum(rate(ai_request_total[5m]))`
- Frontend LCP (avg):
  - `sum(rate(frontend_web_vital_sum{name="LCP"}[5m])) / sum(rate(frontend_web_vital_count{name="LCP"}[5m]))`
- Frontend API latency P95:
  - `histogram_quantile(0.95, sum(rate(frontend_api_latency_bucket[5m])) by (le))`

## Notes

- Avoid high-cardinality labels (do not include userId/sessionId).
- If needed, normalize `endpoint` in frontend (already strips query).
